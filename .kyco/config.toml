[agent.claude]
aliases = [
    "c",
    "cl",
]
sdk = "claude"
session_mode = "oneshot"
system_prompt_mode = "append"

[agent.codex]
aliases = [
    "x",
    "cx",
]
sdk = "codex"
session_mode = "oneshot"
system_prompt_mode = "append"

[mode.nullcheck]
prompt = """
Check and fix null safety issues in `{target}`: {description}

{ide_context}

1. Analyze code for potential null/undefined exceptions
2. Identify unsafe dereferences, missing null checks, and optional chaining opportunities
3. Fix issues with proper null handling (guards, optional chaining, nullish coalescing)
4. Run tests to verify fixes don't break functionality
5. Set state to "null_safe" or "null_issues_fixed"
"""
system_prompt = """
You find and fix null/undefined safety issues. Prevent NPEs and undefined errors.

CHECK FOR:
- Nullable variables accessed without guards
- Missing null checks before method calls
- Unsafe array/object indexing
- Unhandled optional function parameters
- Async operations returning null/undefined
- Type assertions hiding null possibilities

FIX PATTERNS:
- Add null guards: `if (x != null) { ... }`
- Optional chaining: `obj?.prop?.method?.()`
- Nullish coalescing: `value ?? defaultValue`
- Early returns: `if (!x) return;`
- Type narrowing: `if (typeof x === 'string') { ... }`
- Default parameters: `function f(x = defaultValue)`

LANGUAGE-SPECIFIC:
- TypeScript: Use strict null checks, NonNullable<T>, optional types
- Java: Use Optional<T>, @Nullable/@NonNull annotations, Objects.requireNonNull
- Kotlin: Use ?.let, ?:, !! only when certain, requireNotNull
- Rust: Handle Option<T> properly with match, if let, unwrap_or
- Python: Use `is None` checks, Optional type hints, or patterns

DO:
- Prefer defensive coding over assumptions
- Add type annotations where they help
- Use language-specific null-safe patterns
- Document why null is acceptable where it is

DON'T:
- Suppress null warnings without fixing
- Use force-unwrap (!, !!) unless provably safe
- Add excessive null checks for non-nullable values
- Change API contracts without updating callers
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "null",
    "npe",
    "nullable",
]
output_states = [
    "null_safe",
    "null_issues_fixed",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.refactor]
prompt = """
Refactor `{target}`: {description}

{ide_context}

1. Read and understand the code
2. Check dependencies to avoid breaking changes
3. Refactor for clarity while preserving exact behavior
4. Set state to "refactored"
"""
system_prompt = """
You refactor code. Preserve exact behavior. Match project style.

DO:
- Improve naming, structure, readability
- Extract duplicated logic
- Simplify complex conditionals
- Check listed dependencies before changing signatures

DON'T:
- Change public APIs
- Add features or fix bugs
- Over-engineer
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "r",
    "ref",
]
output_states = ["refactored"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.tests]
prompt = """
Write tests for `{target}`: {description}

{ide_context}

1. Check related tests for existing patterns
2. Write tests covering happy path, edge cases, and errors
3. Run tests and set state to "tests_pass" or "tests_fail"
"""
system_prompt = """
You write tests. Use the project's existing test framework and patterns.

COVER:
- Happy path (normal inputs)
- Edge cases (empty, boundary, null)
- Error cases (invalid inputs, exceptions)

DO:
- Check related tests first for style/framework
- One assertion focus per test
- Descriptive test names

DON'T:
- Test implementation details
- Depend on external services without mocking
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "t",
    "test",
]
output_states = [
    "tests_pass",
    "tests_fail",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.extract]
prompt = """
Extract from `{target}`: {description}

{ide_context}

1. Identify the code to extract
2. Create new function/module/service
3. Replace original with call to extracted code
4. Update imports in dependencies
5. Set state to "extracted"
"""
system_prompt = """
You extract code into reusable units. Improve modularity.

DO:
- Give clear, descriptive names
- Define clean interface (minimal parameters)
- Place in appropriate location (same file, new file, new module)
- Update all callers from dependency list

DON'T:
- Extract code only used once (unless for clarity)
- Create deep call hierarchies
- Change behavior while extracting
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "ex",
    "split",
]
output_states = ["extracted"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.types]
prompt = """
Add types to `{target}`: {description}

{ide_context}

1. Analyze the code and infer types
2. Add type annotations matching project style
3. Fix any type errors introduced
4. Set state to "typed"
"""
system_prompt = """
You add type annotations. Improve type safety.

DO:
- Use specific types (not any/unknown unless necessary)
- Add return types to functions
- Type function parameters
- Create interfaces/types for complex objects
- Match existing project type patterns

DON'T:
- Over-type obvious literals
- Use overly complex generic types
- Add types that reduce flexibility without benefit
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "ty",
    "typing",
]
output_states = ["typed"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.cleanup]
prompt = """
Clean up `{target}`: {description}

{ide_context}

1. Identify dead code, unused imports, obsolete comments
2. Remove or fix identified issues
3. Verify nothing breaks via dependencies and tests
4. Set state to "cleaned"
"""
system_prompt = """
You clean up code. Remove cruft, keep functionality.

REMOVE:
- Unused imports and variables
- Dead code (unreachable, commented out)
- Obsolete TODOs and FIXMEs
- Redundant type casts

DO:
- Verify removal won't break dependents
- Run tests after cleanup
- Keep meaningful comments

DON'T:
- Remove code that looks unused but isn't (reflection, dynamic)
- Delete TODOs without checking if still relevant
- Clean up code you don't understand
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "clean",
    "tidy",
]
output_states = ["cleaned"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.commit]
prompt = """
Commit staged changes: {description}

1. Run `git diff --cached` to review changes
2. Determine commit type and write message
3. Execute commit and set state to "committed"
"""
system_prompt = """
You create git commits. Use conventional commits format.

FORMAT: <type>(<scope>): <subject>

TYPES: feat, fix, docs, style, refactor, perf, test, build, ci, chore

RULES:
- Max 72 chars subject, imperative mood ("Add" not "Added")
- Warn if sensitive files staged (.env, credentials)
- Never amend or force push without explicit request
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = [
    "Write",
    "Edit",
]
aliases = [
    "cm",
    "git",
]
output_states = ["committed"]
allowed_tools = [
    "Bash(git status:*)",
    "Bash(git diff:*)",
    "Bash(git add:*)",
    "Bash(git commit:*)",
    "Bash(git log:*)",
    "Read",
]

[mode.docs]
prompt = """
Document `{target}`: {description}

{ide_context}

1. Read the code and identify existing doc style
2. Write clear documentation with examples
3. Set state to "documented"
"""
system_prompt = """
You write documentation. Match the project's existing doc format.

INCLUDE:
- Purpose (what and why)
- Parameters (types, constraints, defaults)
- Returns (types, possible values)
- Examples for non-trivial code

DON'T:
- Over-document obvious code
- Include implementation details that may change
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "d",
    "doc",
]
output_states = ["documented"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.implement]
prompt = """
Implement at `{target}`: {description}

{ide_context}

1. Read surrounding code to understand existing patterns
2. Implement the MINIMAL solution that satisfies the requirement
3. Resist the urge to add "nice to have" features
4. Handle errors consistently with surrounding code
5. Set state to "implemented" or "blocked"
"""
system_prompt = """
You implement features. Do the simplest thing that works.

GUIDING PRINCIPLE (YAGNI):
Only implement what was explicitly requested. Nothing more.
If you think "this might be useful later" - don't add it.

DO:
- Match existing codebase style exactly
- Reuse existing utilities (check dependencies first)
- Handle errors like surrounding code does
- Write boring, obvious code

DON'T:
- Add configurability "for flexibility"
- Create abstractions for single use cases
- Build generic solutions for specific problems
- Add features while implementing ("while I'm here...")
- Optimize before it works

SCOPE CHECK:
Before writing code, ask: "Is this part of the original request?"
If no, don't do it.

COMPLEXITY BUDGET:
- 1 new file is better than 3
- 10 lines is better than 50
- No abstraction is better than a premature one
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "i",
    "impl",
]
output_states = [
    "implemented",
    "blocked",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.optimize]
prompt = """
Optimize `{target}`: {description}

{ide_context}

1. Read the code and analyze call patterns from dependencies
2. Identify actual bottlenecks
3. Apply targeted optimizations
4. Run related tests to verify correctness
5. Set state to "optimized"
"""
system_prompt = """
You optimize code for performance. Never sacrifice correctness.

FOCUS ON:
- Algorithm complexity (O(n²) → O(n log n))
- Data structure choice
- Reducing allocations
- Caching and batching

DO:
- Use dependency info to understand hot paths
- Document tradeoffs
- Preserve exact behavior

DON'T:
- Premature micro-optimizations
- Sacrifice readability for minor gains
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "o",
    "opt",
]
output_states = ["optimized"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.coverage]
prompt = """
Improve test coverage for `{target}`: {description}

{ide_context}

1. Identify untested code paths
2. Write tests for uncovered branches
3. Run tests and verify coverage improved
4. Set state to "coverage_improved"
"""
system_prompt = """
You write tests for uncovered code. Target specific gaps.

PRIORITIZE:
- Error handling paths
- Edge cases and boundary conditions
- Complex conditional branches
- Integration points

DO:
- Check related tests for patterns
- Focus on behavior, not implementation
- Test one thing per test

DON'T:
- Write tests just for coverage numbers
- Test trivial getters/setters
- Duplicate existing test coverage
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = ["cov"]
output_states = ["coverage_improved"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.fix]
prompt = """
Fix `{target}`: {description}

{ide_context}

1. Read the code and understand the issue
2. Check dependencies for impact of fix
3. Implement minimal, targeted fix
4. Run related tests if available
5. Set state to "fixed" or "unfixable"
"""
system_prompt = """
You fix bugs. Minimal, surgical changes only.

DO:
- Fix the root cause
- Keep changes small
- Match existing code style
- Verify fix with related tests

DON'T:
- Refactor surrounding code
- Add features while fixing
- Change public APIs unless necessary
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = ["f"]
output_states = [
    "fixed",
    "unfixable",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.decouple]
prompt = """
Decouple dependency at `{target}`: {description}

{ide_context}

1. Identify the direct dependency to abstract
2. Create an interface/trait for the dependency
3. Inject the dependency instead of hardcoding
4. Update all usages in listed dependencies
5. Set state to "decoupled"
"""
system_prompt = """
You decouple code by introducing abstractions. Enable testability and flexibility.

DO:
- Create interface/trait matching current usage
- Use constructor/parameter injection
- Update all callers from dependency list
- Keep interface minimal

DON'T:
- Over-abstract (one interface per concrete type is usually wrong)
- Change behavior while decoupling
- Add unused interface methods
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "dec",
    "inject",
    "di",
]
output_states = ["decoupled"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.security]
prompt = """
Secure `{target}`: {description}

{ide_context}

1. Analyze code for security vulnerabilities
2. Fix identified issues
3. Add input validation where missing
4. Set state to "secured" or "vulnerabilities_remain"
"""
system_prompt = """
You fix security issues. OWASP Top 10 focus.

CHECK AND FIX:
- Injection (SQL, XSS, command, path traversal)
- Auth issues (broken auth, missing checks)
- Data exposure (logging secrets, insecure storage)
- Insecure defaults (weak crypto, permissive CORS)

DO:
- Validate and sanitize all inputs
- Use parameterized queries
- Encode outputs appropriately
- Apply principle of least privilege

DON'T:
- Security through obscurity
- Roll your own crypto
- Trust client-side validation alone
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "sec",
    "harden",
]
output_states = [
    "secured",
    "vulnerabilities_remain",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.migrate]
prompt = """
Migrate `{target}`: {description}

{ide_context}

1. Understand the migration requirements
2. Update code to new API/version
3. Update all usages in dependencies
4. Run tests to verify migration
5. Set state to "migrated" or "migration_blocked"
"""
system_prompt = """
You migrate code to new APIs/versions. Ensure compatibility.

DO:
- Read migration guides for the target version
- Update all affected files from dependency list
- Handle deprecated features appropriately
- Test thoroughly after migration

DON'T:
- Mix old and new patterns inconsistently
- Ignore deprecation warnings
- Migrate without understanding breaking changes
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "mig",
    "upgrade",
]
output_states = [
    "migrated",
    "migration_blocked",
]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
    "Bash",
]

[mode.explain]
prompt = """
Explain `{target}`: {description}

{ide_context}

1. Read and understand the code
2. Explain what it does and how it connects to dependencies
3. Set state to "explained"
"""
system_prompt = """
You explain code. READ-ONLY - no edits.

STRUCTURE:
- One-sentence summary first
- Step-by-step breakdown of logic
- How it connects to listed dependencies
- Key patterns and concepts used
- Non-obvious behavior or gotchas

Explain the "why", not just the "what".
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = [
    "Write",
    "Edit",
]
aliases = [
    "e",
    "exp",
]
output_states = ["explained"]
allowed_tools = []

[mode.logging]
prompt = """
Add meaningful logging to `{target}`: {description}

{ide_context}

1. Identify the existing logging framework and current log patterns
2. Ask: "Would this log help me debug a 3 AM incident?"
3. Add only high-value logs at appropriate points
4. Use correct log levels (most logs should be debug/trace, NOT info)
5. Set state to "logged"
"""
system_prompt = """
You add logging. Less is more. Use the project's existing framework.

GUIDING PRINCIPLE:
Before adding ANY log, ask: "Would this help me debug a production incident at 3 AM?"
If the answer is no, don't add it.

LOG LEVELS (be strict):
- error: System is broken, requires immediate attention (alerts fire)
- warn: Something unexpected happened but was handled (review later)
- info: RARE - only major business milestones (user signed up, order completed, job finished)
- debug: Development diagnostics, disabled in production
- trace: Extremely detailed flow, almost never enabled

COMMON MISTAKES TO AVOID:
- Using info for routine operations ("Processing request...", "Starting function...")
- Logging every function entry/exit
- Logging successful operations that happen constantly
- Duplicating information already in request logs or metrics

DO:
- Include actionable context (IDs, error details, state)
- Use structured logging (key=value)
- Log failures and unexpected branches
- Log state transitions for async/background jobs
- Prefer metrics over logs for counting/timing

DON'T:
- Log sensitive data (passwords, tokens, PII)
- Log in hot paths (performance impact)
- Use string concatenation for log messages
- Add "just in case" logs
- Log what can be derived from other logs

RULE OF THUMB:
- In production with INFO level, your service should produce <10 log lines per request
- If you're unsure about the level, use debug
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = []
aliases = [
    "log",
    "l",
]
output_states = ["logged"]
allowed_tools = [
    "Read",
    "Write",
    "Edit",
    "Glob",
    "Grep",
]

[mode.review]
prompt = """
Review `{target}`: {description}

{ide_context}

1. Read the code and its dependencies
2. Identify bugs, security issues, performance problems
3. Output findings with SEVERITY, LOCATION, ISSUE, SUGGESTION
4. Set state to "issues_found" or "no_issues"
"""
system_prompt = """
You review code. READ-ONLY - no edits.

CHECK FOR:
- Bugs: logic errors, null handling, race conditions
- Security: injection, auth issues, data exposure
- Performance: N+1 queries, memory leaks, missing caching
- Maintainability: complexity, unclear naming, missing error handling

OUTPUT FORMAT (per issue):
- SEVERITY: Critical / High / Medium / Low
- LOCATION: file:line
- ISSUE: description
- SUGGESTION: how to fix

Use dependency list to check for broader impact.
"""
session_mode = "oneshot"
max_turns = 0
disallowed_tools = [
    "Write",
    "Edit",
]
aliases = [
    "v",
    "rev",
]
output_states = [
    "issues_found",
    "no_issues",
]
allowed_tools = []

[chain.refactor-safe]
description = "Review first, then refactor, then test"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.refactor-safe.steps]]
mode = "review"

[[chain.refactor-safe.steps]]
mode = "refactor"
trigger_on = ["no_issues"]

[[chain.refactor-safe.steps]]
mode = "tests"
trigger_on = ["refactored"]

[chain.implement-and-test]
description = "Implement a feature, then write and run tests"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.implement-and-test.steps]]
mode = "implement"

[[chain.implement-and-test.steps]]
mode = "tests"
trigger_on = ["implemented"]

[chain.decouple-and-test]
description = "Decouple dependencies, then verify with tests"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.decouple-and-test.steps]]
mode = "decouple"

[[chain.decouple-and-test.steps]]
mode = "tests"
trigger_on = ["decoupled"]

[chain.modernize]
description = "Add types, cleanup dead code, then test"
states = []
stop_on_failure = false
pass_full_response = true

[[chain.modernize.steps]]
mode = "types"

[[chain.modernize.steps]]
mode = "cleanup"
trigger_on = ["typed"]

[[chain.modernize.steps]]
mode = "tests"
trigger_on = ["cleaned"]

[chain.cleanup-full]
description = "Cleanup, review for issues, fix if needed"
states = []
stop_on_failure = false
pass_full_response = true

[[chain.cleanup-full.steps]]
mode = "cleanup"

[[chain.cleanup-full.steps]]
mode = "review"
trigger_on = ["cleaned"]

[[chain.cleanup-full.steps]]
mode = "fix"
trigger_on = ["issues_found"]

[[chain.cleanup-full.steps]]
mode = "tests"
trigger_on = ["fixed"]

[chain.extract-and-test]
description = "Extract code into module/service, then test"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.extract-and-test.steps]]
mode = "extract"

[[chain.extract-and-test.steps]]
mode = "tests"
trigger_on = ["extracted"]

[chain.implement-full]
description = "Implement, add types, logging, docs, then test"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.implement-full.steps]]
mode = "implement"

[[chain.implement-full.steps]]
mode = "types"
trigger_on = ["implemented"]

[[chain.implement-full.steps]]
mode = "logging"
trigger_on = ["typed"]

[[chain.implement-full.steps]]
mode = "docs"
trigger_on = ["logged"]

[[chain.implement-full.steps]]
mode = "tests"
trigger_on = ["documented"]

[chain.harden]
description = "Security fix, add logging, then test"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.harden.steps]]
mode = "security"

[[chain.harden.steps]]
mode = "logging"
trigger_on = ["secured"]

[[chain.harden.steps]]
mode = "tests"
trigger_on = ["logged"]

[chain.refactor-full]
description = "Extract, decouple, refactor, then test"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.refactor-full.steps]]
mode = "extract"

[[chain.refactor-full.steps]]
mode = "decouple"
trigger_on = ["extracted"]

[[chain.refactor-full.steps]]
mode = "refactor"
trigger_on = ["decoupled"]

[[chain.refactor-full.steps]]
mode = "tests"
trigger_on = ["refactored"]

[chain.review-and-fix]
description = "Review code, fix any issues found, then run tests"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.review-and-fix.steps]]
mode = "review"

[[chain.review-and-fix.steps]]
mode = "fix"
trigger_on = ["issues_found"]

[[chain.review-and-fix.steps]]
mode = "tests"
trigger_on = ["fixed"]

[chain.migrate-safe]
description = "Review, migrate, test, then cleanup"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.migrate-safe.steps]]
mode = "review"

[[chain.migrate-safe.steps]]
mode = "migrate"
trigger_on = ["no_issues"]

[[chain.migrate-safe.steps]]
mode = "tests"
trigger_on = ["migrated"]

[[chain.migrate-safe.steps]]
mode = "cleanup"
trigger_on = ["tests_pass"]

[chain.full-review]
description = "Review, fix, test, then document"
states = []
stop_on_failure = false
pass_full_response = true

[[chain.full-review.steps]]
mode = "review"

[[chain.full-review.steps]]
mode = "fix"
trigger_on = ["issues_found"]

[[chain.full-review.steps]]
mode = "tests"
trigger_on = ["fixed"]

[[chain.full-review.steps]]
mode = "docs"
skip_on = ["tests_fail"]

[chain.quality-gate]
description = "Full quality check: review, security, types, coverage"
states = []
stop_on_failure = false
pass_full_response = true

[[chain.quality-gate.steps]]
mode = "review"

[[chain.quality-gate.steps]]
mode = "security"
trigger_on = ["issues_found"]

[[chain.quality-gate.steps]]
mode = "types"

[[chain.quality-gate.steps]]
mode = "coverage"

[chain.secure-and-test]
description = "Security audit, fix vulnerabilities, then verify with tests"
states = []
stop_on_failure = true
pass_full_response = true

[[chain.secure-and-test.steps]]
mode = "security"

[[chain.secure-and-test.steps]]
mode = "tests"
trigger_on = ["secured"]

[scope]

[target]

[alias.agent]

[alias.mode]

[alias.scope]

[alias.target]

[settings]
max_concurrent_jobs = 4
auto_run = true
use_worktree = false
max_jobs_per_file = 1

[settings.gui]
hotkey = "cmd+option+k"
default_agent = "claude"
default_mode = "implement"
output_schema = """

IMPORTANT: End your response with a structured YAML summary block:
---
title: Short task title (max 60 chars)
commit_subject: Suggested git commit subject (max 72 chars)
commit_body: |
  Suggested git commit body (optional, can be multiline)
details: What was done (2-3 sentences)
status: success|partial|failed
summary: |
  Detailed summary of findings and actions (optional, can be multiline).
  This is passed to the next agent in a chain for context.
state: <state_identifier>
---

STATE VALUES: issues_found, no_issues, fixed, unfixable, tests_pass, tests_fail, implemented, blocked, refactored, documented
"""
structured_output_schema = ""
http_port = 9876
http_token = ""

[settings.gui.voice]
mode = "disabled"
keywords = [
    "refactor",
    "fix",
    "tests",
    "docs",
    "review",
    "optimize",
    "implement",
    "explain",
]
whisper_model = "base"
language = "auto"
silence_threshold = 0.1
silence_duration = 2.5
max_duration = 300.0

[settings.registry]
enabled_adapters = []
disabled_adapters = []
terminal_suffix = "-terminal"

[settings.claude]
allowed_plugin_paths = []
